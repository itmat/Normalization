.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Matrix 3"
.TH Matrix 3 "2013-09-30" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Matrix \- Multiply and invert Matrices
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Math::Matrix;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The following methods are available:
.SS "new"
.IX Subsection "new"
Constructor arguments are a list of references to arrays of the same
length.  The arrays are copied. The method returns \fBundef\fR in case of
error.
.PP
.Vb 3
\&        $a = new Math::Matrix ([rand,rand,rand],
\&                               [rand,rand,rand],
\&                               [rand,rand,rand]);
.Ve
.PP
If you call  \f(CW\*(C`new\*(C'\fR as method, a zero filled matrix with identical deminsions is returned.
.SS "clone"
.IX Subsection "clone"
You can clone a matrix by calling:
.PP
.Vb 1
\&        $b = $a\->clone;
.Ve
.SS "diagonal"
.IX Subsection "diagonal"
A constructor method that creates a diagonal matrix from a single list
or array of numbers.
.PP
.Vb 2
\&        $p = Math::Matrix\->diagonal(1, 4, 4, 8);
\&        $q = Math::Matrix\->diagonal([1, 4, 4, 8]);
.Ve
.PP
The matrix is zero filled except for the diagonal members, which take the
value of the vector
.PP
The method returns \fBundef\fR in case of error.
.SS "tridiagonal"
.IX Subsection "tridiagonal"
A constructor method that creates a matrix from vectors of numbers.
.PP
.Vb 3
\&        $p = Math::Matrix\->tridiagonal([1, 4, 4, 8]);
\&        $q = Math::Matrix\->tridiagonal([1, 4, 4, 8], [9, 12, 15]);
\&        $r = Math::Matrix\->tridiagonal([1, 4, 4, 8], [9, 12, 15], [4, 3, 2]);
.Ve
.PP
In the first case, the main diagonal takes the values of the vector, while
both of the upper and lower diagonals's values are all set to one.
.PP
In the second case, the main diagonal takes the values of the first vector,
while the upper and lower diagonals are each set to the values of the
second vector.
.PP
In the third case, the main diagonal takes the values of the first vector,
while the upper diagonal is set to the values of the second vector, and the
lower diagonal is set to the values of the third vector.
.PP
The method returns \fBundef\fR in case of error.
.SS "size"
.IX Subsection "size"
You can determine the dimensions of a matrix by calling:
.PP
.Vb 1
\&        ($m, $n) = $a\->size;
.Ve
.SS "concat"
.IX Subsection "concat"
Concatenates two matrices of same row count. The result is a new
matrix or \fBundef\fR in case of error.
.PP
.Vb 2
\&        $b = new Math::Matrix ([rand],[rand],[rand]);
\&        $c = $a\->concat($b);
.Ve
.SS "transpose"
.IX Subsection "transpose"
Returns the transposed matrix. This is the matrix where colums and
rows of the argument matrix are swaped.
.SS "multiply"
.IX Subsection "multiply"
Multiplies two matrices where the length of the rows in the first
matrix is the same as the length of the columns in the second
matrix. Returns the product or \fBundef\fR in case of error.
.SS "solve"
.IX Subsection "solve"
Solves a equation system given by the matrix. The number of colums
must be greater than the number of rows. If variables are dependent
from each other, the second and all further of the dependent
coefficients are 0. This means the method can handle such systems. The
method returns a matrix containing the solutions in its columns or
\&\fBundef\fR in case of error.
.SS "invert"
.IX Subsection "invert"
Invert a Matrix using \f(CW\*(C`solve\*(C'\fR.
.SS "multiply_scalar"
.IX Subsection "multiply_scalar"
Multiplies a matrix and a scalar resulting in a matrix of the same
dimensions with each element scaled with the scalar.
.PP
.Vb 1
\&  $a\->multiply_scalar(2);  scale matrix by factor 2
.Ve
.SS "add"
.IX Subsection "add"
Add two matrices of the same dimensions.
.SS "subtract"
.IX Subsection "subtract"
Shorthand for \f(CW\*(C`add($other\->negative)\*(C'\fR
.SS "equal"
.IX Subsection "equal"
Decide if two matrices are equal.  The criterion is, that each pair
of elements differs less than \f(CW$Math::Matrix::eps\fR.
.SS "slice"
.IX Subsection "slice"
Extract columns:
.PP
.Vb 1
\&  a\->slice(1,3,5);
.Ve
.SS "diagonal_vector"
.IX Subsection "diagonal_vector"
Extract the diagonal as an array:
.PP
.Vb 1
\&  $diag = $a\->diagonal_vector;
.Ve
.SS "tridiagonal_vector"
.IX Subsection "tridiagonal_vector"
Extract the diagonals that make up a tridiagonal matrix:
.PP
.Vb 1
\&  ($main_d, $upper_d, $lower_d) = $a\->tridiagonal_vector;
.Ve
.SS "determinant"
.IX Subsection "determinant"
Compute the determinant of a matrix.
.SS "dot_product"
.IX Subsection "dot_product"
Compute the dot product of two vectors.
.SS "absolute"
.IX Subsection "absolute"
Compute the absolute value of a vector.
.SS "normalizing"
.IX Subsection "normalizing"
Normalize a vector.
.SS "cross_product"
.IX Subsection "cross_product"
Compute the cross-product of vectors.
.SS "print"
.IX Subsection "print"
Prints the matrix on \s-1STDOUT\s0. If the method has additional parameters,
these are printed before the matrix is printed.
.SS "pinvert"
.IX Subsection "pinvert"
Compute the pseudo-inverse of the matrix: ((A'A)^\-1)A'
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 1
\&        use Math::Matrix;
\&
\&        srand(time);
\&        $a = new Math::Matrix ([rand,rand,rand], 
\&                         [rand,rand,rand], 
\&                         [rand,rand,rand]);
\&        $x = new Math::Matrix ([rand,rand,rand]);
\&        $a\->print("A\en");
\&        $E = $a\->concat($x\->transpose);
\&        $E\->print("Equation system\en");
\&        $s = $E\->solve;
\&        $s\->print("Solutions s\en");
\&        $a\->multiply($s)\->print("A*s\en");
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Ulrich Pfeifer <\fIpfeifer@ls6.informatik.uni\-dortmund.de\fR>
.PP
Brian J. Watson <\fIbjbrew@power.net\fR>
.PP
Matthew Brett <matthew.brett@mrc\-cbu.cam.ac.uk>
